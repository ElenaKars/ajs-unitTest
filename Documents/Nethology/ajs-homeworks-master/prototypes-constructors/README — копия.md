# Домашнее задание к лекции «Прототипы, конструкторы»

### **Важные моменты** 

1. Каждая задача выполняется в виде отдельного проекта с собственным GitHub-репозиторием.
2. Код должен проходить ESLint без ошибок.
3. Тесты должны обеспечивать 100-процентное покрытие тестируемых функций по строкам.
4. Решения должны быть построены на базе [шаблона webpack](/ci-template).

В личном кабинете на сайте [netology.ru](http://netology.ru/) в поле комментария к домашней работе добавьте ссылки на ваши GitHub-проекты.

---

## Функция-конструктор

### Легенда

Чтобы упростить поддержку вашей игры и разрастающееся количество персонажей, вы решили внедрить единые правила создания персонажей, и вам в этом помогут конструкторы.

### Описание

Реализуйте функцию-конструктор персонажей:
```javascript
function Character(name, type) {
  // TODO: add logic here
  this.name = name;
  this.type = type;
}
```

Ваша функция-конструктор должна соответствовать требованиям:
- name — строка, минимум 2 символа, максимум — 10;
- type — один из типов (строка): Bowman, Swordsman, Magician, Daemon, Undead, Zombie.

Если передаются некорректные значения, функция-конструктор должна выбрасывать ошибку (`throw new Error(...)`) и не давать возможность создавать объект.

В вашей функции автоматически должны устанавливаться значения полей:
- health: 100;
- level: 1;
- атака/защита:
    1. Bowman: 25/25;
    1. Swordsman: 40/10;
    1. Magician: 10/40;
    1. Undead: 25/25;
    1. Zombie: 40/10;
    1. Daemon: 10/40.

Напишите Unit-тесты, которые обеспечивают 100-процентное покрытие тестируемой функции.

---

## Прототипы

### Легенда

Когда у вас есть функция-конструктор, вы можете использовать возможности прототипов, чтобы реализовать общие функции для разных объектов. Реализуем функцию, которая наносит урон объекту в результате атаки на него.

### Описание

В качестве отправной точки используйте реализацию:
```javascript
function Character(name, type) {
    this.name = name;
    this.type = type;
    this.health = 100;
    this.attack = 10;
    this.defence = 40;
}
```

В прототипе Character реализуйте функцию `damage(points)`, которая меняет внутреннее состояние объекта (`points` — это урон, наносимый персонажу). Функция `damage(points)` ничего не возвращает и рассчитывает итоговое изменение жизни персонажа (`health`) по формуле: `health -= points * (1 — defence/100)`, учитывая, что значение `health >= 0`.

Напишите Unit-тесты, которые обеспечивают 100-процентное покрытие тестируемой функции.

---

## JSDoc * (задача со звёздочкой)

**Важно: это необязательная задача.**

### Легенда

Когда вы приступаете к решению вопросов организации своего кода, встаёт вопрос о его документировании для участников команды. Для этого есть много инструментов, и вы выбрали [JSDoc](http://usejsdoc.org).

### Описание JSDoc

Установите JSDoc в ваш проект с помощью команды:
`npm install --save-dev jsdoc`.

Создайте конфигурационный файл JSDoc — jsdoc.conf.json:
```json
{
  "source": {
    "include": ["src/js"]
  },
  "opts": {
    "encoding": "utf8",
    "destination": "docs",
    "recurse": true
  }
}
```
Создайте файл character.js с вашим приложением в каталоге JS. В нём расположите заглушку функции:
```javascript
/**
 * <Общее описание>
 * 
 * @param <описание параметра>
 * @param <описание параметра>
 * 
 * @throws <описание генерируемой ошибки>
 */ 
function Character(name, type) {
  this.name = name;
  this.type = type;
}
```

Задайте скрипт npm в package.json:
`"doc": "jsdoc -c jsdoc.conf.json"`.


Задокументируйте поведение функции-конструктора Character с использованием doc-комментариев:
- @param {<тип>} <имя> — описание параметра (см. [документацию](http://usejsdoc.org/tags-param.html));
- @throws {<тип>} — описание генерируемого исключения (см. [документацию](http://usejsdoc.org/tags-throws.html)).

Удостоверьтесь, что документация генирируется, запустив `npm run doc`.

Добавьте каталог docs в .gitignore.
